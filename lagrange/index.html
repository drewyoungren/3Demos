<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Box Optimization with Lagrange Multipliers</title>
  <link rel="stylesheet" href="main.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>


      <canvas id="c"></canvas>
      


<div id="info"> <span class="noselect" onclick="javascript:(() => {var el = document.querySelector('#infop'); if (el.style.display == 'block') { console.log('Block found'); el.style.display = 'none'} else {el.style.display = 'block';} } )();"><b>Info</b></span>
      <p id="infop" style="display: block;">Minimize the surface area of a lidless box with fixed volume. 
        <span style="color: #FF0F17;">$$ V = xyz = 32000 \text{cm}^3 $$</span>
        <span id="salevel" style="color: #FFF717;">$$ SA = xy + 2xz + 2yz = 6800 \text{cm}^2$$</span>  Use the controls at right to change the dimensions. Gradients \(\nabla V\) and \(\nabla SA\) are plotted (not to scale) as are the relevant level surfaces.</p>
    </div>

</body>
<script type="module">

/* jshint esversion: 6 */

import * as THREE from 'https://unpkg.com/three@0.121.0/build/three.module.js';
import {OrbitControls} from 'https://unpkg.com/three@0.121.0/examples/jsm/controls/OrbitControls.js';
import {GUI} from './dat.gui.module.js';

const nX = 30; // resolution for surfaces

var scene = new THREE.Scene();
var canvas = document.querySelector("#c");
// var canvas = document.getElementById("canvas-plot-1");

scene.background = new THREE.Color( 0xdddde8 );

var camera = new THREE.PerspectiveCamera(75, canvas.clientWidth/canvas.clientHeight, 0.1, 1000);

camera.position.z = 130;
camera.position.y = 75;
camera.position.x = -25;
camera.lookAt( 40, 40, 20 );


var renderer = new THREE.WebGLRenderer({antialias: true, alpha : true,canvas: canvas});
// renderer.setClearColor("#e5e5f5");

const gui = new GUI();

canvas.width  = canvas.clientWidth;
canvas.height = canvas.clientHeight;
renderer.setViewport(0, 0, canvas.clientWidth, canvas.clientHeight);
renderer.setSize(window.innerWidth, window.innerHeight);
camera.aspect = window.innerWidth / window.innerHeight;

window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    console.log(canvas.width,canvas.clientWidth)
    camera.updateProjectionMatrix();
});

var ii = new THREE.Vector3( 0, 0, 1 );
var jj = new THREE.Vector3( 1, 0, 0 );
var kk = new THREE.Vector3( 0, 1, 0 );

const a = 20;
const b = 60;

//normalize the direction vector (convert to vector of length 1)

var origin = new THREE.Vector3( 0, 0, 0 );
var length = 65;
var hex = 0x330033;
var axesArray = [ii,jj,kk];
var arrayLength = axesArray.length;
for (var i = 0; i < arrayLength; i++) {
    var dir = axesArray[i];
    // dir.normalize(); // not needed for standard basis
    var arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex , 3);
    scene.add( arrowHelper );
    // gui.add(arrowHelper,'visible').name("Axis ${i}");
}
var lineMaterial = new THREE.LineBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.8 } );

for (let j = -10; j <= b; j += 5) {
  var points = [];
  points.push( new THREE.Vector3( j, 0, -10 ) );
  points.push( new THREE.Vector3( j, 0, b ) );

  var geometry = new THREE.BufferGeometry().setFromPoints( points );
  scene.add(new THREE.Line(geometry,lineMaterial));
   
  points = [];
  points.push( new THREE.Vector3( -10, 0, j ) );
  points.push( new THREE.Vector3( b, 0, j ) );

  geometry = new THREE.BufferGeometry().setFromPoints( points );
  scene.add(new THREE.Line(geometry,lineMaterial));

 }

// var axesHelper = new THREE.AxesHelper( b );
// scene.add( axesHelper );


var volGeometry = new THREE.ParametricGeometry(function(u,v,vec) {
    u = (1-u)*a + u*b;
    v = (1-v)*a + v*b;
    vec.set(u,32000/(u*v),v);
}, nX, nX);
var material = new THREE.MeshPhongMaterial({color: 0xFF0717,shininess: 100, side: THREE.DoubleSide});
var materialBack = new THREE.MeshLambertMaterial({color: 0xFFF717, side: THREE.DoubleSide, transparent: true, opacity: 0.8});
var volMesh = new THREE.Mesh(volGeometry, material);
scene.add(volMesh);
// var surf = new THREE.Mesh(geometry, materialBack);
// scene.add(surf);
var volSkel = new THREE.LineSegments(volGeometry, lineMaterial);
scene.add(volSkel);


var light = new THREE.PointLight(0xFFFFFF, 1, 1000);
light.position.set(60,50,40);
scene.add(light);

var light2 = new THREE.AmbientLight( 0x404040 ); // soft white light
scene.add( light2 );

var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
scene.add( light );

var controls = new OrbitControls (camera, renderer.domElement);
controls.autoRotate = false;
controls.target.set( 25,25,25 );


// Make the box. 

var boxData = {x: 20, y:20};

var boxGeometry = new THREE.BoxGeometry(boxData.y,32000/(boxData.x * boxData.y),boxData.x);
var boxMaterial = new THREE.MeshPhongMaterial({color: 0x8383FF,shininess: 80, transparent: true, opacity: .5, side: THREE.DoubleSide});
var box = new THREE.Mesh(boxGeometry,boxMaterial);
box.position.z = boxData.x /2;
box.position.x = boxData.y /2;
box.position.y = 32000/(boxData.x * boxData.y) /2;
scene.add(box);
console.log("Box pos", box.position);

// Update box

function updateBoxData() {
  var geometry = new THREE.BoxGeometry(boxData.y,32000/(boxData.x * boxData.y),boxData.x);
  box.geometry.dispose();
  box.geometry = geometry;
  box.position.z = boxData.x /2;
  box.position.x = boxData.y /2;
  box.position.y = 32000/(boxData.x * boxData.y) /2;

  generateGeometry();
}

var folder = gui.addFolder( 'Box dimensions' );
folder.add(boxData,'x',20,60).onChange(updateBoxData);
folder.add(boxData,'y',20,60).onChange(updateBoxData);

//surface area

// var data = {
//   level: (boxData.x * boxData.y) + 64000/boxData.y + 64000/boxData.x
// };

var data = {
  levelInternal: (boxData.x * boxData.y) + 64000/boxData.y + 64000/boxData.x,
  levelListener: function(val) {
    var element = document.querySelector("#salevel");
    element.innerHTML = "$$ SA = xy + 2xz + 2yz = " + val.toFixed() + "\\text{cm}^2 $$";
    MathJax.typeset();
  },
  get level() {
    return this.levelInternal;
  },
  set level(val) {
    this.levelInternal = val;
    this.levelListener(val);
  }
};

function newtonStep(a) {
  return a - (a*a*a - data.level*a + 4*32000)/(3*a*a - data.level);
}

function rootify(start,tol = .00001) {
  var x = start;
  if (3*x*x == data.level) { return x; }
  var y = newtonStep(x);
  while (Math.abs(y - x) > tol) {
    x = y;
    y = newtonStep(x);
  }
  return y;
}

var xRoot = rootify(20);

console.log(xRoot);
// levels of surface area

var geometry = new THREE.ParametricGeometry(function(u,v,vec) {
      u = (1-u)*17 + u*60;
      v = (1-v)*17 + v*60;
      vec.set(u,(data.level - u*v)/(2*(u + v)),v);
    }, nX,nX);

var surf = new THREE.Mesh(geometry,materialBack);
var skel = new THREE.Mesh(geometry,lineMaterial);

scene.add(surf);
scene.add(skel);

// gradients to surfaces
origin = new THREE.Vector3( boxData.y, 32000/(boxData.x * boxData.y), boxData.x );
dir = new THREE.Vector3( boxData.y + 64000/(boxData.x * boxData.y) ,2*boxData.x + 2*boxData.y, boxData.x + 64000/(boxData.x * boxData.y) );
dir.normalize();
length = 20;
var delF = new THREE.ArrowHelper(dir,origin, length, 0xFFF717);
dir = new THREE.Vector3( 32000/(boxData.y) , (boxData.x * boxData.y), 32000/(boxData.x) );
dir.normalize();
var delG = new THREE.ArrowHelper(dir,origin, length*1.5, 0xFF0717);
scene.add(delF);
scene.add(delG);

function generateGeometry() {

    // reset root coord for intersection

    // xRoot = rootify(xRoot);
    // console.log(xRoot);

    data.level = (boxData.x * boxData.y) + 64000/boxData.y + 64000/boxData.x;

    var origin = origin = new THREE.Vector3( boxData.y, 32000/(boxData.x * boxData.y), boxData.x );
    var dirf = new THREE.Vector3( boxData.y + 64000/(boxData.x * boxData.y) ,2*boxData.x + 2*boxData.y, boxData.x + 64000/(boxData.x * boxData.y) );
    dirf.normalize();
    delF.setDirection(dirf);
    delF.position.copy(origin);
    var dirg = new THREE.Vector3( 32000/(boxData.y) , (boxData.x * boxData.y), 32000/(boxData.x) );
    dirg.normalize();
    delG.setDirection(dirg);
    delG.position.copy(origin);

    surf.geometry.dispose();
    skel.geometry.dispose();

    var geometry = new THREE.ParametricGeometry(function(u,v,vec) {
      u = (1-u)*17 + u*60;
      v = (1-v)*17 + v*60;
      vec.set(u,(data.level - u*v)/(2*(u + v)),v);
    }, nX,nX);

    surf.geometry = geometry;
    skel.geometry = geometry;

}

// var folder = gui.addFolder( 'Function Properties' );

// gui.add( data, 'level', 4800, 6800 ).onChange( generateGeometry );

// generateGeometry();

var render = function() {
    controls.update();
    
    renderer.render(scene, camera);
    requestAnimationFrame(render);
};

requestAnimationFrame(render);

</script>
</html>